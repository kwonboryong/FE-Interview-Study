## 1회차 | JavaScript 기본 개념 답변 정리

> 📅 날짜: 2025-08-14 (목)  
> 📚 주제: JavaScript 기본 개념 정리 (변수, 호이스팅, 이벤트 전파 등)

<br/>

### ✅ 면접 질문 리스트

**1. `var`, `let`, `const` 키워드는 각각 어떤 차이점이 있나요?**

var, let, const는 **모두 변수를 선언하는 키워드**지만, 스코프 범위, 호이스팅 방식, 재선언·재할당 가능 여부가 다릅니다.

**var는 함수 스코프**이고, **선언과 동시에 undefined로 초기화 돼서 변수 선언 전에 변수에 접근이 가능**합니다.

**let과 const는 블록 스코프**입니다. <br/>
그리고 **선언만 호이스팅 되고, 초기화는 선언문에서 이루어지기 때문에 선언 전에 변수에 접근하면 Reference Error가 발생**합니다.

let은 재할당은 가능하지만, 재선언은 불가능하기 때문에 변할 수 있는 변수에 사용하고, <br/>
const는 재선언과 재할당 모두 불가능하기 때문에 값이 변하지 않는 상수에 사용합니다.

- 함수 스코프: 변수가 선언된 함수 안에서만 유효한 범위
- 블록 스코프: if문이나 for문 같은 중괄호 블록 내부에서만 유효한 범위

<br/><br/>

**2. 자바스크립트에서 "호이스팅"이란 무엇인가요?**

호이스팅은 **변수 선언과 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 것처럼 보이는 현상**입니다.

**var**는 선언과 동시에 `undefined`로 초기화되고, **함수 스코프 기준으로 호이스팅**됩니다.

**let과 const**는 **변수 선언만 호이스팅**되고, **초기화는 코드 실행이 실제 선언문에 도달했을 때** 이루어집니다.

- 이 초기화 되기 전의 구간을 **TDZ(Temporal Dead Zone)이**라고 부르고,  
  이때 변수에 접근하면 Reference Error가 발생합니다.

<br/><br/>

**3. 이벤트 전파란 무엇인가요? 전파의 흐름과 단계(캡처링, 버블링)에 대해 설명해주세요.**

이벤트 전파는 **이벤트가 발생한 요소에서 다른 요소로 전파되는 현상**을 말합니다.

전파 단계는 **캡처링 → 타깃 → 버블링 단계** 순으로 흘러갑니다.

- **캡처링** 단계: 이벤트가 최상위 부모 요소에서 타깃 요소까지 내려오는 단계
- **타깃** 단계: 실제 이벤트가 발생한 요소에서 처리되는 단계
- **버블링** 단계: 타깃에서 다시 부모 요소로 올라가는 단계

**브라우저 기본 동작은 버블링**이어서, 이벤트가 자식 요소에서 부모 요소로 올라가는 식으로 작동합니다.

<br/><br/>

**4. 이벤트 전파를 막는 방법에는 어떤 것이 있나요?**

이벤트 전파를 막으려면, **이벤트 관련 메서드**를 사용해서 막을 수 있습니다.

- 대표적으로 **`stopPropagation()`** 메서드를 사용하면, **해당 이벤트가 더 이상 부모 요소로 전파되지 않습**니다.
- **`stopImmediatePropagation()`** 메서드는 **전파를 막는 동시에, 같은 요소에 등록된 다른 이벤트 핸들러 실행도 차단**합니다.
- **전파는 유지하면서 기본 동작만 막고** 싶을 때는 **`preventDefault()`를** 사용합니다.

<br/><br/>

**5. 이벤트 위임(Event Delegation)은 무엇이며, 어떤 상황에서 유용한가요?**

이벤트 위임은 이벤트를 (자식 요소마다 각각 거는 대신) **공통된 부모 요소에 한 번만 등록해서 이벤트 버블링을 이용해 자식 요소의 이벤트를 처리**하는 방법입니다.

**동적으로 추가되는 요소까지 처리**할 수 있고, **불필요한 이벤트 리스너를 줄일 수 있어** 성능 면에서도 효율적입니다.

<br/><br/>

**6. 자바스크립트에서 `this` 키워드는 어떤 의미를 갖고 어떻게 결정되나요?**

this는 **현재 실행 중인 함수나 문맥(context)이 참조하는 객체를 가리킵**니다.

- **일반 함수로 호출**하면, this는 **전역 객체(window)를** 가리킵니다.
- **객체의 메서드로 호출**하면, this는 **해당 메서드를 호출한 객체**가 됩니다.
- **`call`, `apply`, `bind` 메서드를 사용**하면, **첫 번째 인자로 전달한 값**이 this가 됩니다.
- **new 키워드를 사용해 생성자 함수를 호출**하면, **새로 생성되는 객체**가 this가 됩니다.

<br/><br/>

**7. `call()`, `apply()`, `bind()`의 차이점은 무엇이고, 각각 어떤 상황에서 사용하나요?**

`call`, `apply`, `bind`는 **함수의 `this`를 원하는 객체로 변경하기 위해 사용**하는 메서드입니다.

각 메서드는 실행 시점과 인자 전달 방식에서 차이가 있습니다.

- `call()`은 ⇒ this를 변경하고, **인자를 개별로 전달**해서 함수를 즉시 실행합니다.
- `apply()`는 ⇒ this를 변경하고, **인자를 배열로 전달**해서 함수를 즉시 실행합니다.
- `bind()`는 ⇒ **this와 인자를 고정한 새 함수를 반환**하고, 함수를 즉시 실행하지 않습니다.

<br/><br/>

**8. 콜백 함수란 무엇이며 어떤 상황에서 사용하나요?**

콜백 함수는 **다른 함수의 인자로 전달되어서, 해당 함수의 실행 시점에 호출되는 함수**를 말합니다.

보통 **비동기 작업을 처리**할 때 사용합니다.

콜백 함수는 **함수 실행 순서를 제어**하고, **동작을 재사용 가능**하게 만드는 데 유용하지만,
**콜백지옥에 빠지면 가독성**이 떨어지기 때문에, **`Promise`나 `Async/Await`를 이용**해 보완할 수 있습니다.

<br/><br/>

**9. 얕은 복사와 깊은 복사의 차이는 무엇인가요?**

**얕은 복사**는 **객체의 1차원 값만 복사하고, 중첩된 내부 객체는 참조를 복사**합니다.

- 중첩 객체를 수정하면 **원본도 함께 바뀝**니다.

**깊은 복사**는 **중첩된 내부 객체까지 모두 새로운 메모리에 복사**합니다.

- 복사본을 변경해도 **원본에는 영향을 주지 않습니다.**

**얕은 복사**는 ⇒ **전개 연산자(…)나 `Object.assign`** 같은 방법으로 만들 수 있고,
**깊은 복사**는 ⇒ **`structuredClone`** 같은 방법으로 구현할 수 있습니다.

<br/><br/>

**10. 기본형(Primitive)과 참조형(Reference)의 변수 복사는 어떻게 다르게 작동하나요?**

**기본형은** ⇒ **값 자체**를 복사

- 그래서 복사본과 원본은 **완전히 독립적**입니다.

**참조형의 얕은 복사**는 ⇒ **참조값**만 복사

- 복사본과 원본이 **같은 메모리를 공유**하게 됩니다.

**참조형의 깊은 복사**는 ⇒ **값 전체를 새 메모리에 복사**

- 그래서 복사본과 원본이 **완전히 독립적인 객체**가 됩니다.

<br/>
