## 15회차 | TypeScript 기본 질문 정리 (Enums, 유니온, 인터페이스, 타입, 제네릭)

> 📅 날짜: 2025-10-06 (월) <br/>
> 📚 주제: TypeScript 기본 질문 (Enums, 유니온, 인터페이스, 타입, 제네릭)

<br/>

### ✅ 면접 질문 리스트

### 기본 개념

**1. TypeScript가 무엇이고, 왜 사용하나요?**

**TypeScript는 JavaScript에 정적 타입 시스템을 추가한 언어**

- 개발 중에 타입 오류를 미리 잡을 수 있어서, 코드 안정성과 가독성이 높아짐
- 변수, 함수 등에 타입을 명확하게 지정할 수 있어서, 실수를 줄이고 협업할 때도 의도를 쉽게 파악할 수 있음
- 자동 완성이나 타입 추론도 가능해서 생산성이 높아짐

<br/><br/>

**2. Enums(이넘)이 무엇인가요?**

**Enums는 열거형 타입으로, 상수 값으로 정의하고, 하나의 그룹으로 묶어서 사용할 수 있는 기능**

- 요일, 상태값처럼 정해진 값들만 쓰고 싶을 때 사용
- 값을 이름으로 관리할 수 있어서 코드 가독성과 유지보수성이 좋아짐

```typescript
// 정의
enum Status {
  SUCCESS,
  ERROR,
}

// 사용
Status.SUCCESS;
```

<br/><br/>

**3. 유니온 타입(Union Types)이 무엇인가요?**

**유니온 타입은 여러 타입 중 하나를 가질 수 있는 타입을 정의하는 기능**

- 상황에 따라 다른 타입을 허용하고 싶을 때 유용
- **`| (파이프)` 연산자**를 사용해서 여러 타입을 연결할 수 있음
- 서로 다른 타입의 값을 유연하게 처리할 수 있어 함수 매개변수나 상태 관리에서 자주 활용됨
- 유연성을 제공하지만, 그만큼 타입에 대한 체크가 필요함

```typescript
let value: string | number;

value = "hello";
value = 123; // 둘 다 가능
```

<br/><br/>

**4. 인터페이스(Interface)와 타입(Type)의 차이는 무엇인가요?**

둘 다 **객체의 구조를 정의**할 수 있는 기능

**인터페이스는 객체의 구조를 정의하는 키워드**

- **`extends` 키워드**로 다른 인터페이스를 상속해서 확장할 수 있음

<br/>

**타입은 타입을 정의하기 위한 키워드**

- 유니온(`|`) 타입이나 조건부 타입 등 더 복잡한 기능을 사용할 수 있음
- 보통 객체 구조를 정의할 때는 인터페이스, 유니온 같은 타입 변형에는 타입 키워드를 사용함

<br/><br/>

**5. 인터페이스(Interface)와 클래스(class)의 차이는 무엇인가요?**

**인터페이스는 객체의 구조를 정의하는 역할**

- 객체를 **실제 구현은 하지 않고, 구현해야 하는 구조만 정의함**
- 주로 다른 객체나 클래스가 이 인터페이스를 구현하도록 강제하는 데 사용됨

<br/>

**클래스는 인터페이스를 기반으로 객체의 구체적인 동작을 구현하는 역할**

- **생성자(constructor)를 통해 인스턴스를 생성**하고, **메서드를 통해 객체의 동작을 정의**함

<br/><br/>

**6. 제네릭(Generics)이란 무엇인가요?**

**제네릭은 타입을 매개변수처럼 받아서 동적으로 정의할 수 있는 기능**

- **타입을 고정하지 않고, 사용하는 시점에 타입을 지정할 수 있는 기능**
- **`<>(꺾쇠 괄호)` 안**에 대표적으로는 T를 써서 사용
- 같은 로직을 다양한 타입에 적용할 수 있어 중복 코드를 줄이고 타입 안정성을 유지할 수 있음

```typescript
function identity<T>(arg: T): T {
  // T는 제네릭(타입을 나중에 받겠다)
  return arg;
}

let output1 = identity(42); // output1은 number
let output2 = identity("Hello"); // output2는 string
```

<br/><br/>

**7. 제네릭 유틸리티 타입이 무엇이고, 어떤 것들이 있나요?**

**제네릭 유틸리티 타입은 이미 정의된 타입을 변환하거나 활용하기 쉽게 만들어주는 내장 타입 도구**

<br/>

**제네릭 유틸리티 타입 종류**

- **`Partial<T>`**: 모든 속성을 선택적으로 만듦 (부분 업데이트 시 유용)
- **`Readonly<T>`**: 속성을 읽기 전용으로 만듦 (데이터 불변성 유지)
- **`Record<K, T>`**: 특정 키 집합을 값과 매핑
- **`Pick<T, K>`**: 특정 속성만 선택
- **`Omit<T, K>`**: 특정 속성을 제외

<br/><br/>

**8. 컴포넌트의 Props를 TypeScript로 정의할 때 어떤 방식으로 설계하시나요?**

- 먼저 **props의 역할과 사용 위치를 파악**한 뒤 필요한 데이터만 정의
- **필수 속성과 선택 속성을 구분**하고, **데이터 타입은 최대한 구체적으로 지정**
- **유니온 타입을 활용**해서 props에 들어올 값을 더 유연하게 설계
- **재사용할 컴포넌트라면 제네릭**을 써서 범용적인 타입으로 만듦

<br/>
