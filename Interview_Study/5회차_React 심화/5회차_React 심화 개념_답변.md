## 5회차 | React 심화 개념 정리 (상태 관리, 상태 끌어올리기, 상향식 데이터 전달 등)

> 📅 날짜: 2025-08-28 (목) <br/>
> 📚 주제: React 심화 개념 정리 (상태 관리, 상태 끌어올리기, 상향식 데이터 전달 등)

<br/>

### ✅ 면접 질문 리스트

**1. useEffect와 useLayoutEffect는 어떤 차이가 있나요?**

**useEffect**는 **비동기적으로 실행**되어 **컴포넌트가 화면에 그려진 이후 실행**됩니다.

**useLayoutEffect**는 **동기적으로 실행**되어 **DOM이 그려지기 전에 실행**됩니다.

<br/>

그래서 **useEffect는 데이터 요청, 이벤트 등록, 로그 기록 등** 화면을 막지 않는 작업에 사용하고,

**useLayoutEffect는 레이아웃 계산이나 스타일 조정**처럼 즉시 반영이 필요한 작업에 사용합니다.

<br/><br/>

**2. React에서는 상태를 보통 어떻게 관리하나요?**

컴포넌트 내부의 간단한 상태는 **useState 훅**으로 관리합니다.

상태가 복잡한 경우에는 **useReducer 훅**으로 상태 로직을 분리해서 관리할 수 있습니다.

상태를 여러 컴포넌트에서 공유해야 경우에는 **Context API**를 활용하거나 **Redux, Zustand 같은 상태 관리 라이브러리**를 사용합니다.

<br/><br/>

**3. 상태 끌어올리기(Lifting State Up)라는 개념에 대해 설명해주세요.**

**여러 컴포넌트가 공통된 상태를 공유해야 할 때, 그 상태를 부모 컴포넌트에서 관리하는 방식**입니다.

**부모 컴포넌트가 상태와 상태 업데이트 함수를 가지고, 자식 컴포넌트들은 props를 통해 상태를 전달 받는 형태**입니다.

<br/>

이렇게 하면 데이터가 한 곳에서만 관리해서 일관성을 유지할 수 있고, 데이터 중복을 방지할 수 있습니다.

그러나 컴포넌트 트리가 깊어질 경우 props drilling 문제가 생길 수 있습니다.

```jsx
// 부모 컴포넌트
function Parent() {
  const [text, setText] = useState(""); // 상태를 부모에서 관리

  return (
    <div>
      <InputChild onChange={setText} />
      <DisplayChild value={text} />
    </div>
  );
}

// 자식 컴포넌트 1: 입력창
function InputChild({ onChange }) {
  return (
    <input
      type="text"
      onChange={(e) => onChange(e.target.value)}
      // 값을 입력받고 onChange로 부모에게 전달
      placeholder="글자를 입력하세요"
    />
  );
}

// 자식 컴포넌트 2: 입력값 보여주기
function DisplayChild({ value }) {
  return <p>입력한 값: {value}</p>; // 부모로부터 받은 상태 표시
}
```

<br/><br/>

**4. 자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하는 방법에 대해 설명해주세요. <br/> = 상향식 데이터 전달(lifting state up)이 뭔가요?**

자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하려면,

**부모 컴포넌트가 함수를 정의해서 props로 자식 컴포넌트로 전달**하고,

**자식 컴포넌트는 그 함수의 인자에 원하는 값을 넣어서 호출**하면 데이터가 부모 컴포넌트로 전달됩니다.

<br/>

- 상향식 데이터 전달(lifting state up): 자식 컴포넌트에서 부모 컴포넌트로 데이터나 이벤트를 전달하는 방식

```jsx
// 부모
function Parent() {
  // 부모가 만든 함수, 자식이 호출하면 값(value)을 받음
  const handleData = (value) => {
    console.log("부모가 받은 값:", value);
  };

  // 자식에게 함수를 props로 전달
  return <Child onSend={handleData} />;
}

// 자식
function Child({ onSend }) {
  return (
    // 부모에게 데이터 보내기
    <button onClick={() => onSend("안녕하세요!")} />
  );
}
```

<br/><br/>

**5. Props와 State는 어떤 차이가 있나요?**

**Props**는 **부모 컴포넌트가 자식 컴포넌트에 전달하는 읽기 전용 데이터**이고,

**불변 객체**라서 자식 컴포넌트에서 직접 수정할 수 없습니다.

<br/>

**State**는 **컴포넌트 내부에서 관리하는 값**입니다.

Props와 달리 컴포넌트가 **직접 변경**할 수 있고, 상태가 바뀌면 컴포넌트가 리렌더링 되는 특징이 있습니다.

<br/><br/>

**6. React에서는 왜 상태(State)를 직접 수정하지 않고 setState 같은 함수를 사용하나요?**

**상태를 직접 수정하면, React가 그 변화를 감지하지 못해서 화면이 리렌더링 되지 않습니다.**

setState 같은 상태 변경 함수를 사용해야 React가 상태 변화를 감지하고 추적해서 UI를 업데이트할 수 있습니다.

<br/><br/>

**7. React는 컴포넌트에서 상태 변화가 생겼을 때, 어떻게 그 변화를 감지해서 UI를 다시 렌더링하나요?**

React는 상태나 props 값이 바뀌어서 컴포넌트에서 **setState 같은 함수를 호출될 때, 상태 변화를 감지**합니다.

이때 **이전 상태와 새로운 상태를 비교**하고, **변경된 값이 있으면 새로운 Virtual DOM을 생성**합니다.

그리고 **이 Virtual DOM을 이전 Virtual DOM과 비교한** 뒤, **변경된 부분만 실제 DOM에 적용**해서 UI를 업데이트합니다.

<br/><br/>

**8. React에서 상태(State)의 불변성을 유지하려면 어떤 방식으로 관리해야 하나요?**

상태를 직접 수정하지 않고, **새로운 값을 만들어서 setState로 업데이트**해야 합니다.

React는 상태가 변경될 경우, **상태의 주소값이 변경되는 것으로 상태 변경을 감지**합니다.

그렇기 때문에 **기존 데이터를 직접 수정하면 리렌더링이 안 되고**, **새로운 객체나 배열로 만들어서 수정**해야 합니다.

예를 들어 배열을 수정할 때는 push 대신 spread 연산자나 concat, filter, map 등의 메서드를 사용합니다.

이렇게 해야 React가 값의 참조가 바뀐 것을 감지하고, 리렌더링할 수 있습니다.

<br/><br/>

**9. setState는 동기적으로 동작하나요, 아니면 비동기적으로 동작하나요?**  
 **그렇게 동작하는 이유도 함께 설명해주세요.**

**setState는 비동기적으로 동작**합니다.

React는 **성능 최적화를 위해 여러 setState 호출을 모아서 한 번에 처리**하기 때문에 비동기적으로 동작합니다.

이렇게 비동기적으로 동작하기 때문에 **불필요한 리렌더링**을 줄이고, **UI의 반응성을 유지**할 수 있습니다.

<br/><br/>

**10. React에서 리스트를 렌더링할 때, key로 index를 사용하는 것이 괜찮나요?**  
 **문제가 된다면, 왜 문제가 되는지와 어떤 값을 key로 사용하는 것이 적절한지 설명해주세요.**

index를 key로 사용하면

⇒ **항목이 추가되거나 삭제돼서 순서가 바뀌었을 때**, **React가 항목을 제대로 구분하지 못해서** 불필요한 리렌더링이나 UI 오류가 발생할 수 있습니다.

그렇기 때문에 리스트의 key는 항목을 식별할 수 있는 고유한 id 같은 값(ex. DB에서 받은 id)을 사용해야 합니다.

<br/>

설명 추가

- React에서 리스트의 key는 각 항목을 고유하게 식별하기 위해 사용됨
- React는 key를 기준으로 어떤 항목이 변경됐는지 판단함
- 근데 Index는 위치 기준임  
  → 항목이 추가 or 삭제되면 항목의 위치가 바뀜  
  → 항목 자체는 바뀌었는데 index는 그대로임  
  → React가 오해함

<br/>
