## 6회차 | React 심화(2) 개념 정리 (컴포넌트, 리렌더링 조건, SSR/CSR, 성능 최적화, 코드 스플리팅)

> 📅 날짜: 2025-09-01 (월) <br/>
> 📚 주제: React 심화(2) 개념 정리 (컴포넌트, 리렌더링 조건, SSR/CSR, 성능 최적화, 코드 스플리팅)

<br/>

### ✅ 면접 질문 리스트

**1. HTML과 React의 이벤트 처리 차이점은 무엇인가요?**

**HTML**에서는 **이벤트 핸들러를 소문자로 작성**하고, **문자열로 함수 이름**을 넘깁니다.

이 경우 DOM이 전역에서 해당 함수를 찾아 실행합니다.

```jsx
onclick = "handleClick()";
```

<br/>

**React**에서는 **이벤트 핸들러를 camelCase로 작성**하고, **함수 자체를 전달**합니다.

그래서 컴포넌트 내부에서 정의한 함수를 그대로 연결할 수 있고, 상태나 변수를 안전하게 사용할 수 있습니다.

```jsx
onClick = { handleClick };
```

<br/>

또한 **HTML**에서는 **false를 반환**하는 식으로 이벤트의 기본 동작을 막을 수 있지만,

**React**에서는 반드시 **preventDefault()**를 호출해서 이벤트의 기본동작을 막아야 합니다.

<br/><br/>

**2. 제어 컴포넌트와 비제어 컴포넌트의 차이는 무엇인가요?**

제어 컴포넌트와 비제어 컴포넌트의 차이는 **폼의 값을 관리하는 주체가 React냐 DOM이냐**의 차이입니다.

**제어 컴포넌트**는 **폼의 입력값이 React의 state로 관리됩**니다.

사용자가 입력할 때마다 상태가 업데이트되고, 다시 그 상태가 input의 value 속성에 반영되기 때문에 **React가 값의 변화를 직접 제어**합니다.

```jsx
import { useState } from "react";

export default function ControlledInput() {
  const [value, setValue] = useState("");

  return (
    <div>
      <h3>제어 컴포넌트</h3>
      <input
        type="text"
        value={value} // 상태값을 input의 value로 반영
        onChange={(e) => setValue(e.target.value)} // 입력할 때마다 상태 업데이트
      />
      <p>입력한 값: {value}</p>
    </div>
  );
}
```

<br/>

**비제어 컴포넌트**는 **폼의 입력값을 DOM이 관리**합니다.

**React의 state와는 독립적**이고, 필요할 때 **ref를 통해 값에 접근**할 수 있습니다.

```jsx
import { useRef } from "react";

export default function UncontrolledInput() {
  const inputRef = useRef < HTMLInputElement > null;

  const handleShowValue = () => {
    alert(inputRef.current?.value); // 필요할 때 DOM에서 값 읽어오기
  };

  return (
    <div>
      <h3>비제어 컴포넌트</h3>
      <input type="text" ref={inputRef} /> {/* React state로 제어하지 않음 */}
      <button onClick={handleShowValue}>값 확인</button>
    </div>
  );
}
```

<br/><br/>

**3. 컴포넌트를 나눌 때 기준은 무엇인가요?**

**단일 책임 원칙**에 따라 하나의 컴포넌트는 하나의 역할만 하도록 나누는 게 기본적입니다.

공통적으로 **반복되는 UI**나 **독립적으로 동작**하는 기능, 혹은 **재사용 가능한 단위**를 기준으로 분리합니다.

button이나 input 같은 요소는 별도의 컴포넌트로 만들고, 더 큰 화면은 작은 단위 컴포넌트들을 조합해서 구성하는 편입니다.

<br/><br/>

**4. 컴포넌트는 언제 리렌더링되나요?**

컴포넌트는 **state**가 바뀌거나 **props**가 바뀔 때 리렌더링 됩니다.

**부모 컴포넌트가 리렌더링**되면 자식 컴포넌트도 리렌더링 되고, **context 값이 변해도** 리렌더링이 발생합니다.

<br/><br/>

**5. 컴포넌트 재사용성을 높이기 위해 어떤 방법을 사용하시나요?**

컴포넌트의 재사용성을 높이기 위해서 **단일 책임 원칙**을 지켜서 설계합니다.

**props로 동작을 제어**할 수 있게 만들어서 다양한 상황에 활용할 수 있도록 하기도 하고, **children을 활용**해서 내부 콘텐츠는 유연하게 바꿀 수 있도록 설계합니다.

<br/>

실제로 프로젝트에서는 버튼이나 input 같은 컴포넌트를 만들 때, 크기나 색상 같은 속성들을 variant로 설정해두고 값을 props로 받아서 사용했습니다.

이렇게 하니 해당 컴포넌트를 다양한 상황에서 사용할 수 있어서 컴포넌트의 재사용성을 높일 수 있었습니다.

<br/><br/>

**6. 상태 관리의 복잡도가 높아질 때 어떻게 관리하시나요?**

특정 컴포넌트 내부에서만 필요한 값은 **useState()로** 관리하고, 상태가 많아지거나 복잡해지면 **useReducer()를** 사용해서 관리했습니다.

<br/>

실제로 프로젝트를 진행하면서 사용자 정보를 입력받는 form을 구현할 때, 이 폼에 입력값 뿐만 아니라 유효성 검사 상태, 에러 메시지 등의 여러 상태가 얽혀 있어서 useState()만으로는 관리가 어려웠습니다.

그래서 useReducer()를 사용해서 액션 타입 별로 로직을 정의했고, 상태 전환 흐름이 명확해지도록 관리했던 경험이 있습니다.

<br/>

그 외에는 상태의 범위에 따라 **로컬 상태와 전역 상태로 분리**해서 관리했고, 최대한 **비즈니스 로직과 UI 상태를 분리**해서 유지보수성을 높일 수 있도록 했습니다.

<br/><br/>

**7. Vanilla JS와 React의 차이는 무엇인가요?**

바닐라 JS와 React는 **DOM 조작 방식과 UI 구조화 방식**에 차이가 있습니다.

**바닐라 JS**에서는 **DOM을 직접 선택해서 조작**해야 하고, 상태가 바뀔 때마다 **수동으로 화면을 업데이트**해야 합니다.

**React**는 상태가 바뀌면 **자동으로 UI가 업데이트** 되는 선언적 방식입니다.

**UI를 컴포넌트 단위**로 쪼갤 수 있어서 유지보수가 편리합니다.

<br/><br/>

**8. React는 기본적으로 어떤 렌더링 방식을 사용하나요?**

React는 기본적으로 **CSR(Client Side Rendering)** 입니다.

그래서 **브라우저에서 JS가 실행되면서 화면이 그려집니다.**

다만 **Next.js 같은 프레임워크**를 사용하면 React로도 **SSR(Server Side Rendering)을 구현**할 수 있습니다.

<br/><br/>

**9. 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)의 차이는 무엇인가요?**

**SSR(Server Side Rendering)은** **서버에서 HTML을 미리 만들어서 브라우저에 전달하는 방식**입니다.

**초기 로딩**이 빠르고 **검색엔진 최적화(SEO)에 유리**하지만, **서버 부담이 크고 인터랙션이 느릴** 수 있다는 단점이 있습니다.

<br/>

**CSR(Client Side Rendering)은** **브라우저에서 JS가 실행되며 화면이 그려지는 방식**입니다.

SPA처럼 **부드러운 사용자 경험**을 제공하지만, **초기 로딩**이 느리고 **검색엔진 최적화(SEO)에는 불리**하다는 단점이 있습니다.

<br/>

- **SPA(Single Page Application)**
  : 처음에 한 번만 HTML, JS, CSS 리소스를 받아오고, 이후에는 **클라이언트(JS)에서 라우팅**을 처리하는 방식 (필요한 데이터만 서버에서 받아옴) - CSR을 구현하는 애플리케이션 구조 - 화면 전환은 빠르지만, 실제로는 페이지가 새로고침 되지 않고 JS가 화면을 바꿔주는 구조

<br/><br/>

**10. React에서 성능 최적화를 위해 어떤 방법들을 사용하시나요?**

1. **메모이제이션**을 활용합니다.

   **useMemo, useCallback**으로 값과 함수를 캐싱하고, **React.memo**로 컴포넌트를 메모이제이션해서 불필요한 연산과 리렌더링을 줄였습니다.

2. **코드 스플리팅**을 활용합니다.

   **React.lazy**와 **Suspense**로 잘 사용하지 않는 컴포넌트를 지연 로딩 시켜서 실제로 필요한 시점에만 로딩하도록 했습니다.

3. **이미지 최적화**를 적용합니다.

   이미지는 **WebP 포맷**을 사용하거나 **'loading' 속성에 'lazy'를 설정**해서(`loading="lazy"` ) 초기 로딩 시 불필요한 리소스 요청을 줄였습니다.

이러한 방법들을 적용하면서 프로젝트에서는 초기 로딩 속도와 렌더링 효율성을 어느정도 개선할 수 있었습니다.

<br/><br/>

**11. 코드 스플리팅(Code Splitting)이란 무엇이고, React에서 어떻게 하나요?**

**코드 스플리팅**은 **JS 파일을 여러 조각으로 나눠서 필요한 순간에만 불러오는 기술**입니다.

**초기 로딩 속도**를 줄이고, **자주 사용하지 않는 기능은 나중에 로딩** 시키기 때문에 성능 최적화에 유용합니다.

<br/>

React에서는 **React.lazy와 Suspense**를 사용해 코드 스플리팅을 적용할 수 있습니다.

**React.lazy**는 **특정 컴포넌트를 필요할 때만 불러와**서 초기 로딩 속도를 줄이는 기능이고, <br/> **Suspense**는 해당 컴포넌트가 **로딩되는 동안 보여줄 fallback UI**를 정의하는 기능입니다.

**React.lazy**는 **비동기 로딩**이기 때문에 반드시 **Suspense와 함께 사용**해서 로딩 UI를 표시해야 합니다.

<br/>

실제 프로젝트에서 잘 사용하지 않는 설정 페이지와 모달 컴포넌트에 lazy를 적용해서 해당 페이지를 열 때만 로딩 되도록 했고, Suspense를 통해 로딩되는 동안 로딩 UI를 보여줘서 사용자 경험을 개선한 경험이 있습니다.

```jsx
import React, { Suspense } from "react";

const SettingsPage = React.lazy(() => import("./SettingsPage"));

export default function App() {
  return (
    <div>
      <h1>메인 화면</h1>

      {/* lazy 컴포넌트는 Suspense로 감싸야 함 */}
      <Suspense fallback={<div>로딩 중...</div>}>
        <SettingsPage />
      </Suspense>
    </div>
  );
}
```

<br/>
