## 4회차 | React 기본(2) 개념 답변 정리

> 📅 날짜: 2025-08-25 (월) <br/>
> 📚 주제: React 기본(2) 개념 정리 (State, React Hooks, 메모이제이션, Props 등)

<br/>

### ✅ 면접 질문 리스트

**1. State에 대해 설명해주세요.**

**State**는 **컴포넌트 내부에서 데이터를 저장하고 관리하는 값**입니다.

사용자의 입력이나 이벤트에 따라 값이 변경되고, <br/> **값이 바뀌면 React는 자동으로 UI를 리렌더링해서 화면에 반영**합니다.

보통 `useState`나 `useReducer` 같은 훅으로 상태를 정의하고 관리합니다.

<br/><br/>

**2. React Hooks에 대해 설명해주세요.**

**React Hooks**는 **함수형 컴포넌트에서도 상태 관리나 생명주기 기능을 사용할 수 있게 해주는 함수**입니다.

대표적인 훅으로는 **useState, useEffect, useRef** 등이 있고, 여러 훅을 조합해서 **커스텀 훅**을 만들어 사용할 수 있습니다.

**훅은 호출 순서가 중요**해서 **항상 컴포넌트 최상단에서만 호출**해야 하고, <br/> **조건문이나 반복문 안에서 호출하면 안 된다**는 특징이 있습니다.

→ 호출 순서가 바뀌면 React가 상태를 제대로 추적할 수 없기 때문

<br/><br/>

**3. 기억나는 React Hook에 대해 설명해주세요.** (최소 3개 이상)

**useState**는 **컴포넌트의 상태(state)를 만들고 관리할 수 있는 훅**입니다.

**상태 값과 그 값을 업데이트하는 함수를 반환**하고, **상태 값이 변경되면 컴포넌트가 자동으로 리렌더링**됩니다.

```jsx
const [count, setCount] = useState(0);
```

<br/>

**useEffect**는 **컴포넌트가 렌더링 된 이후에 부수 효과 작업을 실행하는 훅**입니다.

두 번째 인자인 **의존성 배열에 값을 넣어서 실행 시점을 제어**할 수 있고, **cleanup 함수를 return 해서 언마운트할 때 정리**할 수 있습니다.

```jsx
useEffect(() => {
  console.log("마운트됨");

  return () => {
    console.log("언마운트됨");
  };
}, []);
```

<br/>

**useRef**는 **렌더링과 상관없이 값을 저장**해야 하거나 **DOM 요소에 접근**할 때 사용합니다.

**값이 변해도 컴포넌트는 리렌더링되지 않는다**는 특징이 있습니다.

```jsx
const inputRef = useRef(null);
```

<br/><br/>

**4. 메모이제이션(memoization)에 대해 설명해주세요.**

**메모이제이션**은 **한 번 계산한 결과를 저장해 두었다가, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 재사용하는 방법**입니다.

메모이제이션을 통해 **불필요한 연산을 줄이고 성능을 최적화**할 수 있습니다.

<br/><br/>

**5. 리액트에서 메모이제이션을 어떤 방식으로 활용할 수 있나요?**

React에서는 **useMemo, useCallback, React.memo**를 사용하여 메모이제이션을 활용할 수 있습니다.

**useMemo**는 **계산된 값을 메모이제이션**해서 **의존성 배열 값이 바뀔 때만 재계산**합니다.

**useCallback**은 **함수 자체를 메모이제이션**해서 **의존성 배열 값이 바뀔 때만 해당 함수를 재생성**하도록 합니다.

- 주로 자식 컴포넌트에 props로 함수를 넘겨줄 때 사용합니다.

**React.memo**는 **컴포넌트를 메모이제이션**해서 **props가 바뀌지 않았다면 리렌더링을 건너뛰고, 이전 결과 재사용**하도록 합니다.

셋 다 **불필요한 계산**이나 **리렌더링을 막고**, **성능을 최적화**하는 데 유용합니다.

<br/><br/>

**6. React.memo와 useMemo의 차이에 대해 설명해주세요.**

**React.memo**는 **컴포넌트 자체를 메모이제이션**합니다.

부모로부터 전달받는 **props가 변경되지 않으면 리렌더링하지 않고, 이전 결과를 그대로 재사용**합니다.

<br/>

**useMemo**는 **계산된 값만 메모이제이션**합니다.

**복잡한 연산이나 로직을 캐싱**해두고, **의존성 배열의 값이 바뀔 때만 다시 계산**하도록 합니다.

<br/><br/>

**7. Props란 무엇인가요?**

**Props**는 **부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용하는 객체**입니다.

함수의 **매개변수처럼 동작**하고, 자식 컴포넌트가 데이터를 받아서 사용할 수 있게 해줍니다.

props는 **읽기 전용**이기 때문에 **자식 컴포넌트에서는 읽기만 가능하고 직접 수정할 수는 없습니다.**

<br/><br/>

**8. Props Drilling이란 무엇이고, 어떻게 해결할 수 있나요?**

**Props Drilling**은 **부모 컴포넌트에서 최종 자식 컴포넌트로 값을 전달해야 할 때, 여러 자식 컴포넌트를 거쳐서 매번 props를 이어서 넘겨줘야 하는 방식**를 말합니다.

<br/>

**Props Drilling 문제**는 **Context API를 사용해서 해결**할 수 있습니다.

**Context API**는 **필요한 컴포넌트가 직접 데이터를 꺼내 쓸 수 있어서, 상위 컴포넌트에서 하위 컴포넌트로 props를 일일이 전달하지 않아도 됩**니다.

**Zustand, Redux 같은 전역 상태 관리 라이브러리**를 활용해도 props drilling 문제를 해결할 수 있습니다.

<br/><br/>

**9. Context API란 무엇인가요?**

**Context API**는 **컴포넌트 트리 전반에서 데이터를 전역적으로 공유할 수 있는 방법**입니다.

부모 컴포넌트에서 `Provider`를 통해 값을 전달하면, 하위 컴포넌트는 중간 단계를 거치지 않고도 `useContext`로 바로 데이터를 가져올 수 있습니다.

**Props drilling 문제를 피할 수 있고, 로그인 정보, 테마, 언어 설정** 같은 전역적으로 공통된 데이터가 필요할 때 사용합니다.

<br/>

**사용법**

1. **Context 생성 ⇒** **React.createContext()로** Context 생성

   ```jsx
   const MyContext = React.createContext(defaultValue);
   ```

2. **Provider ⇒ Provider 컴포넌트**를 사용해 데이터를 제공, 하위 컴포넌트들이 이 데이터를 소비할 수 있도록 함

   ```jsx
   <MyContext.Provider value={someValue}>
     <App />
   </MyContext.Provider>
   ```

3. **useContext() ⇒** 하위 컴포넌트에서 **useContext 훅**을 사용해 데이터 사용

   ```jsx
   const value = useContext(MyContext);
   ```

<br/><br/>

**10. Key Props를 사용하는 이유에 대해 설명해주세요.**

**Key Props**는 **리스트를 렌더링 할 때, 각 항목을 구분하고 추적하기 위한 고유한 식별자**입니다.

React는 이 **Key를 보고 어떤 항목이 추가되거나 삭제됐는지 추적**합니다.

그래서 Key가 없으면 불필요하게 전체를 리렌더링할 수 있지만, **Key를 제대로 부여하면 변경된 부분만 업데이트**할 수 있어 **성능이 최적화**됩니다.

- Key는 배열 내부의 각 엘리먼트에 고유하게 부여되고, 이 값이 바뀌지 않으면 React가 해당 엘리먼트를 동일한 것으로 인식해서 불필요한 리렌더링을 하지 않음

<br/><br/>

**11. Ref의 용도에 대해 설명해주세요.**

**Ref**는 **컴포넌트가 특정 값을 기억하거나 DOM 요소에 직접 접근할 수 있게 해주는 기능**입니다.

**값이 변해도 리렌더링이 발생하지 않는다**는 특징이 있고, <br/> 주로 **브라우저 API와 상호작용할 때**나 **DOM 요소를 직접 조작할 때** 사용합니다.

<br/>
